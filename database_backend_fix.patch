diff --git a/src/java/database/DatabaseManager.java b/src/java/database/DatabaseManager.java
index d4d0ed2..daae634 100644
--- a/src/java/database/DatabaseManager.java
+++ b/src/java/database/DatabaseManager.java
@@ -20,6 +20,7 @@ import java.sql.Statement;
 import java.time.LocalDateTime;
 import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.concurrent.atomic.AtomicInteger;
 import org.json.simple.JSONArray;
 import org.json.simple.JSONObject;
 import org.json.simple.parser.JSONParser;
@@ -31,14 +32,48 @@ import security.SecurityCode;
  */
 public class DatabaseManager 
 {
-    static {
-        createDataValueTable();
-        createManualDataValueTable();
-        DatabaseManager.createDataValueTable();
-        DatabaseManager.createErrorLogsTable();
-        DatabaseManager.createManualDataNamesTable();
-        DatabaseManager.createUserTable();
-        DataReceiver.getParameters().map(DataParameter::getName).subscribeOn(Schedulers.io()).blockingSubscribe(DatabaseManager::insertDataName);
+    // TODO: Make this more elegant. Database needs to be initialized when first setup, 
+    // but we cannot setup the database until AFTER the servlet has begun running ore we get
+    // an 'Allocate' exception. So we need to have a Test-and-Test-and-Set type of initializer
+    // loop. This MUST be refactored before production. - L.J
+    // TYLER: DO NOT DELETE THIS, PLEASE ACTUALLY CHECK WHAT NEEDS TO BE MERGED AND DO NOT DISCARD
+    // CHANGES TO THIS FILE THAT ARE NOT YOUR OWN.
+    private static final int DATABASE_UNINITIALIZED = 2;
+    private static final int DATABASE_INITIALIZING = 1;
+    private static final int DATABASE_INITIALIZED = 0; 
+    private static AtomicInteger INIT_STATE = new AtomicInteger(DATABASE_UNINITIALIZED); 
+    
+    /**
+     * Initialization function that ensures it is initialized only once and that any
+     * race conditions are satisfied by checking the INIT_STATE; if it it currently being
+     * initialized it is not safe to proceed, so they spin and wait anyway. 
+     */
+    public static void init() {
+        int status;
+        // Database is not initialized yet
+        while ((status = INIT_STATE.get()) != DATABASE_INITIALIZED) {
+            // If we're the lucky thread to be selected, initialize.
+            // A weak compare and swap is used to help with potential memory contention in the case it is not initialized.
+            if (status == DATABASE_UNINITIALIZED && INIT_STATE.weakCompareAndSet(DATABASE_UNINITIALIZED, DATABASE_INITIALIZING)) {
+                DatabaseManager.createErrorLogsTable();
+                DatabaseManager.createDataValueTable();
+                DatabaseManager.createManualDataValueTable();
+                DatabaseManager.createDataValueTable();
+                DatabaseManager.createManualDataNamesTable();
+                DatabaseManager.createUserTable();
+                
+                // Need to fill parameter table as this is potentially first time running
+                // At least on the actual server...
+                DataReceiver.getParameters().map(DataParameter::getName).subscribeOn(Schedulers.io()).blockingSubscribe(DatabaseManager::insertDataName);
+                
+                // Alert spinning threads...
+                INIT_STATE.set(DATABASE_INITIALIZED);
+            } else if (status == DATABASE_INITIALIZING) { // We are spinning waiting for initialization
+                // Spin becuase we have to wait anyway...
+                while (INIT_STATE.get() != DATABASE_INITIALIZED) { }
+            }
+        }
+        
     }
     /*
         Creates the data value table
@@ -230,8 +265,9 @@ public class DatabaseManager
             createTable.execute(createSQL);
         }
         catch (Exception ex)//SQLException ex 
-        {
-            LogError("Error creating Error Logs Table: " + ex.printStackTrace());
+        {   
+            // L.J: Changed as you can't use LogError if the log table isn't setup
+            System.out.println("Error creating Error Logs Table: " + ex);
             ex.printStackTrace();
         }
         finally
         {
@@ -242,6 +278,7 @@ public class DatabaseManager
             }
             catch(SQLException e)
             {
+                // L.J: Changed as you can't use LogError if the log table isn't setup
                 LogError("Error closing statement: " + e);
             }
         }
diff --git a/src/java/servlets/AdminServlet.java b/src/java/servlets/AdminServlet.java
index b2309f6..f567439 100644
--- a/src/java/servlets/AdminServlet.java
+++ b/src/java/servlets/AdminServlet.java
@@ -19,6 +19,7 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.FutureTask;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
 import javax.servlet.ServletException;
 import javax.servlet.annotation.WebServlet;
 import javax.servlet.http.HttpServlet;
@@ -40,18 +41,22 @@ import utilities.FileUtils;
 public class AdminServlet extends HttpServlet {
     
 private static final JSONObject BAD_REQUEST = new JSONObject();
+
 static {
     BAD_REQUEST.put("status", "Generic Error...");
 }
+
+    
     protected void processRequest(HttpServletRequest request, HttpServletResponse response)
             throws ServletException, IOException {
-
+        
         HttpSession session = request.getSession(true);//Create a new session if one does not exists
         final Object lock = session.getId().intern();
         session.setAttribute("user", new common.User());
         common.User admin = (common.User) session.getAttribute("user");
         String action = request.getParameter("action");
         
+        DatabaseManager.init();
         /*
             Admin is manually inputting data into the ManualDataValues table
         
@@ -481,4 +486,6 @@ static {
     public String getServletInfo() {
         return "Short description";
     }// </editor-fold>
+    
+    
 }
\ No newline at end of file
